# web安全

## 1. CSRF攻击

**CSRF**是跨站请求伪造的缩写，也被称为**XSRF**， 是一种挟制用户在当前已登录的**Web**应用程序上执行非本意的操作的攻击方法。**因为CSRF攻击利用的是冲着浏览器分不清发起请求是不是真正的用户本人。**也就是说，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

###  a. CSRF的基本攻击原理

1. 用户Alice登录和访问某银行网站A，保留**cookie**。
2. Alice被某些信息诱导访问危险网站B。
3. 危险网站B上有一个`<img>`标签：<img src="http://www.examplebank.com/account=Alice&amount=1000&payfor=Badman" >
4. 这个标签的src不指向一张图片，而是一个http请求，这个请求向银行要求将Alice的1000元转给Badman，由于Alice的浏览器上有**cookie**，这样浏览器发出的这个请求就能得到响应执行。
5. 这样Alice的钱就被偷了。

### b. CSRF的防范

黑客仅仅靠CSRF发起攻击，他只能借助受害者的cookie骗取服务器的信任，但是黑客并不能凭借拿到cookie，也看不到 cookie的内容。这就告诉我们，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行csrf的保护。而保护的关键，是 **在请求中放入黑客所不能伪造的信息**

#### *<u>验证码</u>*

添加验证码来识别是不是用户主动去发起这个请求，由于一定强度的验证码机器无法识别，因此危险网站不能伪造一个完整的请求。这种方法防范性高，但是简单粗暴，对用户不友好。

#### *<u>HttpOnly</u>*

CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的[XSS](https://so.csdn.net/so/search?q=XSS&spm=1001.2101.3001.7020)漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。

#### *<u>Token</u>*

使用**token**来代替验证码验证。由于黑客并不能拿到和看到cookie里的内容，所以无法伪造一个完整的请求。其思路如下：

1. 服务器随机产生csrf-token，然后以csrf-token为密钥散列生成一段密文
2. 把csrf-token和密钥都交给前端
3. 前端发起请求时把密文和csrf-token都交给后端
4. 后端对token和密文进行正向散列验证，看token能不能生成同样的密文
5. 这样即使黑客拿到了csrf-token也无法拿到密文。

这种方式的极大地提高了安全性，且对用户十分友好，其缺点是需要hash计算，性能成本增加，并且会使cookie变得臃肿。

## 2. XSS攻击

**XSS**是垮脚本攻击，其原理是不需要做任何登录验证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。

XSS防范措施：

1. 编码：对用户输入的数据进行HTML Entity 编码。把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。
2. 过滤：移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。
3. 校正：避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。(DOM Parse：它的作用是把文本解析成DOM结构)

## 3. SQL注入

**SQL注入**即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。